## Домашние работы к курсу «Введение в программирование»

[Условия домашних заданий](http://www.kgeorgiy.info/courses/prog-intro/homeworks.html)

[Домашнее задание 17. Вычисление в разных типах](hw17_expressions_generics)
----
1. Добавьте в программу разбирающую и вычисляющую выражения поддержку различных типов.
   - Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления
   - Вторым аргументом командной строки программа должна принимать выражение для вычисления.
   - Реализация не должна содержать непроверяемых преобразований типов.
   - Реализация не должна использовать аннотацию `@SuppressWarnings`.
2. При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.
#### Модификации
 * *Базовая*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](java/expression/generic/Tabulator.java) и
      сроить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
    * [Исходный код тестов](java/expression/generic/GenericTest.java)
 * *Сmm*
    * Дополнительно реализовать унарные операции:
        * `count` – число установленных битов, `count 5` равно 2.
    * Дополнительно реализовать бинарную операцию (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
    * [Исходный код тестов](java/expression/generic/GenericCmmTest.java)
 * *Ls*
    * Дополнительно реализовать поддержку режимов:
        * `l` – вычисления в `long` без проверки на переполнение;
        * `s` – вычисления в `short` без проверки на переполнение.
    * [Исходный код тестов](java/expression/generic/GenericLsTest.java)
 * *CmmUls*
    * Реализовать операции из модификации *Cmm*.
    * Дополнительно реализовать поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `l` – вычисления в `long` без проверки на переполнение;
        * `s` – вычисления в `s` без проверки на переполнение.
    * [Исходный код тестов](java/expression/generic/GenericCmmUlsTest.java)
 * *CmmUfb*
    * Реализовать операции из модификации *Cmm*.
    * Дополнительно реализовать поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `f` – вычисления в `float` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение.
    * [Исходный код тестов](java/expression/generic/GenericCmmUfbTest.java)



[Домашнее задание 16. Очереди](hw16_linked_queue)
----
1. Определите интерфейс очереди Queue и опишите его контракт.
2. Реализуйте класс LinkedQueue — очередь на связном списке.
3. Выделите общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue.

#### Модификации
 * *Базовая*
    * [Исходный код тестов](java/queue/QueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/QueueTest.jar)
 * *IfWhile*
    * Добавить в интерфейс очереди и реализовать методы
        * `removeIf(predicate)` – удалить элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `retainIf(predicate)` – удалить элементы, не удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `takeWhile(predicate)` – сохранить подряд идущие элементы, удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
        * `dropWhile(predicate)` – удалить подряд идущие элементы, не удовлетворяющие
            [предикату](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно
    * [Исходный код тестов](java/queue/QueueIfWhileTest.java)
    * [Откомпилированные тесты](artifacts/queue/QueueIfWhileTest.jar)


[Домашнее задание 15. Очередь на массиве](hw15_contracts_queue)
----
1. Найдите инвариант структуры данных «очередь». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит null.
2. Реализуйте классы, представляющие циклическую очередь с применением массива.
   - Класс ArrayQueueModule должен реализовывать один экземпляр очереди с использованием переменных класса.
   - Класс ArrayQueueADT должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
   - Класс ArrayQueue должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
   - Должны быть реализованы следующие функции (процедуры) / методы:
      - enqueue – добавить элемент в очередь;
      - element – первый элемент в очереди;
      - dequeue – удалить и вернуть первый элемент в очереди;
      - size – текущий размер очереди;
      - isEmpty – является ли очередь пустой;
      - clear – удалить все элементы из очереди.
   - Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
   - Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3. Напишите тесты к реализованным классам.

#### Модификации
 * *Базовая*
    * Классы должны находиться в пакете `queue`
    * [Исходный код тестов](java/queue/ArrayQueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueTest.jar)
 * *Deque* (сложная)
    * Реализовать методы
        * `push` – добавить элемент в начало очереди
        * `peek` – вернуть последний элемент в очереди
        * `remove` – вернуть и удалить последний элемент из очереди
    * [Исходный код тестов](java/queue/ArrayQueueDequeTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueDequeTest.jar)
 * *IndexedDeque*
    * Реализовать модификацию *Deque*
    * Реализовать методы
        * `get` – получить элемент по индексу, отсчитываемому с головы
        * `set` – заменить элемент по индексу, отсчитываемому с головы
    * [Исходный код тестов](java/queue/ArrayQueueIndexedDequeTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueIndexedDequeTest.jar)

[Домашнее задание 14. Бинарный поиск, контракты](hw14_contracts_binsearch)
----
1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.
3. Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
- Имя основного класса — BinarySearch.
- Первый аргумент командной строки — число x.
- Последующие аргументы командной строки — элементы массива a.
5. Пример запуска: java BinarySearch 3 5 4 3 2 1. Ожидаемый результат: 2.
#### Модификации
 * *Базовая*
    * Класс `BinarySearch` должен находиться в пакете `search`
    * [Исходный код тестов](java/search/BinarySearchTest.java)
    * [Откомпилированные тесты](artifacts/search/BinarySearchTest.jar)
 * *Shift*
    * На вход подается отсортированный массив, циклически сдвинутый на `k`
      элементов. Требуется найти `k`. Все числа в массиве различны.
    * Класс должен иметь имя `BinarySearchShift`
    * [Исходный код тестов](java/search/BinarySearchShiftTest.java)
    * [Откомпилированные тесты](artifacts/search/BinarySearchShiftTest.jar)


[Домашнее задание 13. Обработка ошибок](hw13_exceptions)
----
1. Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
- ошибки разбора выражений;
- ошибки вычисления выражений.
2. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
3. Человеко-читаемые сообщения об ошибках должны выводится на консоль.
4. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).
#### Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [Parser](java/expression/exceptions/Parser.java)
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
    * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
 * *PowLog2*
    * Дополнительно реализуйте унарные операции:
        * `log2` – логарифм по уснованию 2, `log2 10` равно 3;
        * `pow2` – два в степени, `pow2 4` равно 16.
    * [Исходный код тестов](java/expression/exceptions/ExceptionsPowLog2Test.java)
 * *PowLog*
    * Дополнительно реализуйте бинарные операции (максимальный приоритет):
        * `**` – возведение в степень, `2 ** 3` равно 8;
        * `//` – логарифм, `10 // 2` равно 3.
    * [Исходный код тестов](java/expression/exceptions/ExceptionsPowLogTest.java)


[Домашнее задание 12. Разбор выражений](hw12_expressions_parser)
----
1. Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида
``` x * (x - 2)* x + 1 ```

2. В записи выражения могут встречаться: умножение *, деление /, сложение +, вычитание -, унарный минус -, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные (x) и произвольное число пробельных символов в любом месте (но не внутри констант).

3. Приоритет операторов, начиная с наивысшего:
- унарный минус;
- умножение и деление;
- сложение и вычитание.

Разбор выражений рекомендуется производить методом рекурсивного спуска. Алгоритм должен работать за линейное время.

#### Модификации
 * *Базовая*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [Parser](java/expression/parser/Parser.java)
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](tests/java/expression/TripleExpression.java)
    * [Исходный код тестов](tests/java/expression/parser/ParserTest.java)
 * *Shifts*
    * Дополнительно реализуйте бинарные операции:
        * `<<` – сдвиг влево, минимальный приоритет (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` – сдвиг вправо, минимальный приоритет (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
    * [Исходный код тестов](tests/java/expression/parser/ParserShiftsTest.java)
 * *ReverseDigits*
    * Реализуйте операции из модификации *Shifts*.
    * Дополнительно реализуйте унарные операции (приоритет как у унарного минуса):
        * `reverse` – число с переставленными цифрами, `reverse -12345` равно -54321;
        * `digits` – сумма цифр числа, `digits -12345` равно 15.
    * [Исходный код тестов](tests/java/expression/parser/ParserReverseDigitsTest.java)


[Домашнее задание 11. Выражения](hw11_expressions)
----
1. Разработайте классы Const, Variable, Add, Subtract, Multiply, Divide для вычисления выражений с одной переменной.

2. Классы должны позволять составлять выражения вида
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).evaluate(5)
```

3. Метод toString должен выдавать запись выражения в полноскобочной форме. Например
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toString()
```
должен выдавать ```((2 * x) - 3)```.

4. Метод toMiniString должен выдавать выражение с минимальным числом скобок. Например
```
new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
).toMiniString()
```
должен выдавать ```2 * x - 3```.

5. Реализуйте метод equals, проверяющий, что два выражения совпадают. 

6. При выполнение задания следует обратить внимание на:

- Выделение общего интерфейса создаваемых классов.

- Выделение абстрактного базового класса для бинарных операций.

#### Модификации
 * *Базовая*
    * Реализуйте интерфейс [Expression](tests/java/expression/Expression.java)
    * [Исходный код тестов](tests/java/expression/ExpressionTest.java)
        * Запускать c аргументом `easy` или `hard`
 * *Triple*
    * Дополнительно реализуйте интерфейс [TripleExpression](tests/java/expression/TripleExpression.java)
    * [Исходный код тестов](tests/java/expression/TripleExpressionTest.java)

[Домашнее задание 10. Игра n,m,k](hw10_mnk_game)
----
1. Реализуйте игру m,n,k.

2. Добавьте обработку ошибок ввода пользователя.

3. Проверку выигрыша нужно производить за O(k).

4. Предотвратите жульничество: у игрока не должно быть возможности достать Board из Position.

#### Модификации
 * *Multiplayer*
    * Добавьте поддержку значков `-` и `|`
    * Добавьте возможность игры для 3 и 4 игроков

[Домашнее задание 9. Markdown to HTML](hw9_md2html)
----
1. Разработайте конвертер из Markdown-разметки в HTML.

2. Конвертер должен называться Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой.

#### Модификации
 * *Link*
    * Добавьте поддержку ```[ссылок с _выделением_](https://kgeorgiy.info)```:
        ```&lt;a href='https://kgeorgiy.info'>ссылок с &lt;em>выделением&lt;/em>&lt;/a>```
    * [Исходный код тестов](tests/java/md2html/Md2HtmlLinkTest.java)
    * [Откомпилированные тесты](tests/artifacts/md2html/Md2HtmlLinkTest.jar)
 * *Mark*
    * Добавьте поддержку `~выделения цветом~`: `<mark>выделения цветом</mark>`
    * [Исходный код тестов](tests/java/md2html/Md2HtmlMarkTest.java)
    * [Откомпилированные тесты](tests/artifacts/md2html/Md2HtmlMarkTest.jar)

Исходный код тестов: [Md2HtmlTest.java](tests/java/md2html/Md2HtmlTest.java)

Откомпилированные тесты: [Md2HtmlTest.jar](tests/artifacts/md2html/Md2HtmlTest.jar)


[Домашнее задание 7. Разметка](hw7_markup)
----
1. Разработайте набор классов для текстовой разметки.

2. Класс Paragraph может содержать произвольное число других элементов разметки и текстовых элементов.

3. Класс Text – текстовый элемент.

4. Классы разметки Emphasis, Strong, Strikeout – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.

5. Все классы должны реализовывать метод toMarkdown(StringBuilder), которой должен генерировать Markdown-разметку по следующим правилам.

#### Модификации
 * *HTML*
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * выделеный текст окружается тегом `em`;
      * сильно выделеный текст окружается тегом `strong`;
      * зачеркнутый текст окружается тегом `s`.
    * [Исходный код тестов](tests/java/markup/HtmlTest.java)
 * *HTML списки*
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, тег `ol`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, тег `ul`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `li`: последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](tests/java/markup/HtmlListTest.java)

Исходный код тестов:

 * [MarkdownTest.java](tests/java/markup/MarkdownTest.java)
 * [AbstractTest.java](tests/java/markup/AbstractTest.java)


[Домашнее задание 6. Подсчет слов++](hw6_wordstat++)
----
1. Разработайте класс WordStatIndex, который будет подсчитывать статистику встречаемости слов во входном файле.

2. Выходной файл должен содержать все различные слова, встречающиеся во входном файле, в порядке их появления. Для каждого слова должна быть выведена одна строка, содержащая слово, число его вхождений во входной файл и номера вхождений этого слова среди всех слов во входном файле.

3. Программа должна работать за линейное от размера входного файла время.

4. Для реализации программы используйте Collections Framework.

5. Реализуйте и примените класс IntList, компактно хранящий список целых чисел.

Исходный код тестов:

* [WordStatIndexTest.java](tests/java/wordStat/WordStatIndexTest.java)
* [WordStatIndexChecker.java](tests/java/wordStat/WordStatIndexChecker.java)

Откомпилированные тесты: [WordStatIndexTest.jar](tests/artifacts/wordStat/WordStatIndexTest.jar)


[Домашнее задание 5. Свой сканнер](hw5_scanner)
----
1. Реализуйте свой аналог класса Scanner на основе Reader.

2. Примените разработанный Scanner для решения заданий «Реверс» и «Статистика слов».

3. Код, управляющий чтением должен быть общим.

4. Код, выделяющий числа и слова должен быть общим.

#### Модификации
 * *Sort*
    * Строки должны быть отсортированы по сумме в обратном порядке
      (при равенстве сумм – в порядке обратном следованию во входе).
      Числа в строке так же должны быть отсортированы в обратном порядке.
    * [Исходный код тестов](tests/java/reverse/FastReverseSortTest.java)
    * [Откомпилированные тесты](tests/artifacts/reverse/FastReverseSortTest.jar)
 
Исходный код тестов:

* [FastReverseTest.java](tests/java/reverse/FastReverseTest.java)

Откомпилированные тесты: [FastReverseTest.jar](tests/artifacts/reverse/FastReverseTest.jar)


[Домашнее задание 4. Подсчет слов](hw4_wordstat)
----
Разработайте класс WordStat, который будет подсчитывать статистику встречаемости слов во входном файле.

Словом называется непрерывная последовательность букв, апострофов и тире (Unicode category Punctuation, Dash).
Для подсчета статистики, слова приводятся к нижнему регистру.

#### Модификации
 * *Words*
    * В выходном файле слова должны быть упорядочены в лексикографическом порядке
    * Класс должен иметь имя `WordStatWords`
    * [Исходный код тестов](tests/java/wordStat/WordStatWordsTest.java)
    * [Откомпилированные тесты](tests/artifacts/wordStat/WordStatWordsTest.jar)
 * *Sort*
    * Пусть _n_ – число слов во входном файле,
      тогда программа должна работать за O(_n_ log _n_).

Исходный код тестов:

* [WordStatInputTest.java](tests/java/wordStat/WordStatInputTest.java)
* [WordStatChecker.java](tests/java/wordStat/WordStatChecker.java)

Откомпилированные тесты: [WordStatInputTest.jar](tests/artifacts/wordStat/WordStatInputTest.jar)


[Домашнее задание 3. Реверс](hw3_reverse)
----
Разработайте класс Reverse, читающий числа из стандартного входа, и выводящий их на стандартный вывод в обратном порядке.

#### Модификации:
 * *Even*
    * Выведите только четные числа (в реверсивном порядке)
    * Класс должен иметь имя `ReverseEven`
    * [Исходный код тестов](tests/java/reverse/ReverseEvenTest.java)
    * [Откомпилированные тесты](tests/artifacts/reverse/ReverseEvenTest.jar)
 * *Linear*
    * Пусть _n_ – сумма числа чисел и строк во входе,
      тогда программе разрешается потратить не более 5n+O(1) памяти

Исходный код тестов:

* [ReverseTest.java](tests/java/reverse/ReverseTest.java)
* [ReverseChecker.java](tests/java/reverse/ReverseChecker.java)

Откомпилированные тесты: [ReverseTest.jar](tests/artifacts/reverse/ReverseTest.jar)


[Домашнее задание 2. Сумма чисел](hw2_sum)
----
Разработайте класс Sum, который при запуске из командной строки будет складывать переданные в качестве аргументов целые числа и выводить их сумму на консоль.

#### Модификации
  * *Long*
    * Входные данные являются 64-битными целыми числами
    * Класс должен иметь имя `SumLong`
    * [Исходный код тестов](tests/java/sum/SumLongTest.java)
    * [Откомпилированные тесты](tests/artifacts/sum/SumLongTest.jar)
 * *Hex*
    * Шестнадцатеричные числа имеют префикс `0x`
    * Класс должен иметь имя `SumHex`
    * [Исходный код тестов](java/sum/SumHexTest.java)
    * [Откомпилированные тесты](tests/artifacts/sum/SumHexTest.jar)

Исходный код тестов:

* [SumTest.java](tests/java/sum/SumTest.java)
* [SumChecker.java](tests/java/sum/SumChecker.java)
* [Базовые классы](tests/java/base/)

